/*! For license information please see ftar-v-cam.js.LICENSE.txt */
!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.VCAM=n():e.VCAM=n()}(this,(()=>(()=>{"use strict";var __webpack_modules__={"../util/rtc-connection.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaConnectionProvider: () => (/* binding */ MediaConnectionProvider)\n/* harmony export */ });\n\nfunction printMediaLineOrder(sdp) {\n // Split the SDP into lines\n const lines = sdp.split("\\r\\n");\n    \n // Filter lines that start with "m="\n const mediaLines = lines.filter(line => line.startsWith("m="));\n \n // Print the order of m-lines with direction\n console.log("Order of m-lines (with direction):");\n \n mediaLines.forEach((line, index) => {\n     const mediaType = line.split(" ")[0].substring(2); // Extract media type (audio, video, etc.)\n     \n     // Look for direction attributes in the SDP\n     let direction = "unknown"; \n     if (lines.some(l => l.includes(`a=sendonly`))) {\n         direction = "outgoing";\n     } else if (lines.some(l => l.includes(`a=recvonly`))) {\n         direction = "incoming";\n     } else if (lines.some(l => l.includes(`a=sendrecv`))) {\n         direction = "sendrecv";\n     }\n     \n     // Print the media line and its direction\n     console.log(`${index + 1}: ${line} (Direction: ${direction})`);\n });\n}\nfunction wrapPayload(payload,iframeId){\n    let sendObject = {}\n   \n    if (iframeId)\n        sendObject[iframeId] = payload\n    else\n        sendObject = payload\n    return sendObject\n\n}\n\nclass MediaConnectionProvider{\n    constructor(postMessageProvider,holderId,iframeId){\n        this.iframeId = iframeId\n        this.holderId = holderId\n        this.postMessageProvider = postMessageProvider\n        // const config = {\n        //     sdpSemantics: "unified-plan",\n        //     iceTransportPolicy: "all",\n        //     bundlePolicy: "max-bundle",\n        // };\n        const configuration = {\n            iceServers: [], // No STUN or TURN servers\n            iceTransportPolicy: "all",\n          };\n        this.peerConnection = new RTCPeerConnection(configuration);\n\n        \n        // console.log("transiver",transiver)\n        // this.peerConnection.addTransceiver(\'audio\', { direction: \'sendrecv\' });\n        this.peerConnection.ontrack = event => {\n            \n            console.log("ontrack",holderId)\n            console.log(event.track)\n            // console.log(event.streams[0].getTracks())\n            const track = event.track\n            if (holderId == "iframe"){\n                if (track.kind == "audio"){\n                    if (this.onaudioready)this.onaudioready(track)\n                }\n            }else if (holderId == "host"){\n               \n                if (track.kind == "video"){\n                    if (this.onflexatarready) this.onflexatarready(track)\n                }else{\n                    if (this.ondelayedaudio)this.ondelayedaudio(track)\n                }\n            }\n            // console.log("audio received",event.streams )\n            // for (const stream of event.streams){\n            //     console.log(stream.getTracks())\n            // }\n            // mediastream = event.streams[0]\n           \n        };\n\n        this.peerConnection.onicecandidate = event => {\n            console.log("onicecandidate")\n            if (event.candidate) {\n   \n               \n                postMessageProvider.postMessage({flexatar:wrapPayload({ type: \'ice-candidate\', candidate: JSON.stringify(event.candidate) },this.iframeId)}, \'*\');\n            }\n        };\n        this.peerConnection.onconnectionstatechange = () => {\n            console.log(\'Connection State:\', this.peerConnection.connectionState);\n            if (this.peerConnection.connectionState == "connected"){\n               \n                // this.isNegotiating = false\n            }\n           \n        };\n        this.isNegotiating = true\n        // if (holderId == "iframe"){\n            this.peerConnection.onnegotiationneeded = async () => {\n                console.log(\'Negotiation needed...\',holderId);\n                if (this.isNegotiating) return\n                this.isNegotiating = true\n                // this.offerMessage()\n                // if (holderId == "host")\n                    postMessageProvider.postMessage(wrapPayload({flexatar:await this.offerMessage()},this.iframeId), \'*\');\n                // else{\n                //     postMessageProvider.postMessage({flexatar:{type:"renegotiate"}}, \'*\');\n                // }\n               \n            }\n        // }\n    }\n    // addTransiver(direction){\n    //     const transiver = this.peerConnection.addTransceiver(\'video\', { direction: direction });\n\n    // }\n    async recvOffer(data){\n        console.log("recvOffer")\n\n        // console.log(\'Offer SDP:\', data.sdp);\n        const remoteDesc = new RTCSessionDescription({ type: \'offer\', sdp: data.sdp });\n        // console.log("remoteDesc",remoteDesc)\n        await this.peerConnection.setRemoteDescription(remoteDesc);\n\n        // Create an answer\n        const answer = await this.peerConnection.createAnswer();\n        await this.peerConnection.setLocalDescription(answer);\n\n        // Send the answer back to the parent\n        // const sdp = this.peerConnection.localDescription.sdp \n        // this.postMessageProvider.postMessage({flexatar:{ type: \'answer\', sdp: sdp }}, \'*\');\n        console.log("send answer")\n        this.postMessageProvider.postMessage({flexatar:wrapPayload({ type: \'answer\', sdp: answer.sdp },this.iframeId)}, \'*\');\n        // window.parent.postMessage({flexatar:{ type: \'answer\', sdp: this.peerConnection.localDescription.sdp }}, \'*\');\n        // console.log(\'answer SDP:\', this.peerConnection.localDescription.sdp);\n    }\n    async recvAnswer(data){\n        console.log("recvAnswer")\n        const remoteDesc = new RTCSessionDescription({ type: \'answer\', sdp: data.sdp });\n        // console.log("answer remoteDesc",remoteDesc)\n        await this.peerConnection.setRemoteDescription(remoteDesc);\n    }\n    async addIceCandidate(data){\n        await this.peerConnection.addIceCandidate(JSON.parse(data.candidate));\n    }\n    async offerMessage(){\n\n        const offer = await this.peerConnection.createOffer();\n        await this.peerConnection.setLocalDescription(offer);\n        console.log(this.holderId)\n        // printMediaLineOrder(offer.sdp)\n\n        return { type: \'offer\', sdp: offer.sdp }\n    }\n    addAudioTrack(audiotrack){\n       \n        if (audiotrack){\n            if (this.audioTransiver){\n                this.audioTransiver.sender.replaceTrack(audiotrack).then(() => {\n                    console.log(\'Track replaced successfully.\');\n                }).catch((error) => {\n                    console.error(\'Error replacing track:\', error);\n                });\n                // this.audioTransiver.stop()\n            }else{\n                console.log("setting new transiver",this.holderId)\n                this.audioTransiver = this.peerConnection.addTransceiver(audiotrack, { direction: \'sendonly\' });\n               \n            }\n\n            // this.peerConnection.addTrack(mediaStream.getAudioTracks()[0], mediaStream)\n        }else{\n            if (this.audioTransiver){\n                this.peerConnection.getSenders().forEach(sender => {\n                    if (sender.track && sender.track.kind === \'audio\') {\n                        this.peerConnection.removeTrack(sender);\n                    }\n                });\n                this.audioTransiver.stop()\n                this.audioTransiver = null\n            }\n        }\n        // mediaStream.getAudioTracks().forEach(track => this.peerConnection.addTrack(track, mediaStream));\n    }\n    addAllTraks(mediaStream){\n        // this.peerConnection.addStream(mediaStream);\n        mediaStream.getTracks().forEach(track => {\n            const sender = this.peerConnection.addTransceiver(track, { direction: \'sendonly\' });\n\n        //     // console.log("track to add",track)\n            // const sender = this.peerConnection.addTrack(track,mediaStream)\n        //     console.log(sender)\n        });\n    }\n\n}\n\n//# sourceURL=webpack://VCAM/../util/rtc-connection.js?')},"../util/util.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64ToUint8Array: () => (/* binding */ base64ToUint8Array),\n/* harmony export */   bufferToBase64: () => (/* binding */ bufferToBase64),\n/* harmony export */   cacheObjectURL: () => (/* binding */ cacheObjectURL),\n/* harmony export */   checkFileType: () => (/* binding */ checkFileType),\n/* harmony export */   fetchArrayBuffer: () => (/* binding */ fetchArrayBuffer),\n/* harmony export */   getCookie: () => (/* binding */ getCookie),\n/* harmony export */   getUint8ArrayFromCache: () => (/* binding */ getUint8ArrayFromCache),\n/* harmony export */   imageMimeTypes: () => (/* binding */ imageMimeTypes),\n/* harmony export */   listCacheKeys: () => (/* binding */ listCacheKeys),\n/* harmony export */   mediaStreamFromArrayBufer: () => (/* binding */ mediaStreamFromArrayBufer),\n/* harmony export */   mediaStreamFromUrl: () => (/* binding */ mediaStreamFromUrl),\n/* harmony export */   retrieveObjectURLFromCache: () => (/* binding */ retrieveObjectURLFromCache),\n/* harmony export */   retryWithDelay: () => (/* binding */ retryWithDelay),\n/* harmony export */   storeInCache: () => (/* binding */ storeInCache),\n/* harmony export */   wait: () => (/* binding */ wait)\n/* harmony export */ });\n\nasync function  wait(ms){\n    await new Promise(resolve=>{setTimeout(resolve,ms)})\n}\n\nasync function retryWithDelay(handler,delayList){\n    if (delayList.length == 0){\n        return false\n    }\n    await wait(delayList[0])\n    delayList.shift()\n    const isComplete  = await handler()\n    if (isComplete) return true\n    return await retryWithDelay(handler,delayList)\n}\n\nfunction getCookie(name) {\n    const value = `; ${document.cookie}`;\n    const parts = value.split(`; ${name}=`);\n    if (parts.length === 2) return parts.pop().split(\';\').shift();\n}\n// export function eraseAllCookie() {\n//     let cookies = document.cookie.split("; ");\n//     for (let c = 0; c < cookies.length; c++) {\n//         let d = window.location.hostname.split(".");\n//         while (d.length > 0) {\n//             let cookieBase = encodeURIComponent(cookies[c].split(";")[0].split("=")[0]) + \'=; expires=Thu, 01-Jan-1970 00:00:01 GMT; domain=\' + d.join(\'.\') + \' ;path=\';\n//             let p = location.pathname.split(\'/\');\n         \n//             document.cookie = cookieBase + \'/\';\n           \n//             while (p.length > 0) {\n//                 document.cookie = cookieBase + p.join(\'/\');\n//                 p.pop();\n//             };\n//             d.shift();\n//         }\n//     }\n// }\n\nasync function bufferToBase64(buffer) {\n    // use a FileReader to generate a base64 data URI:\n    const base64url = await new Promise(r => {\n      const reader = new FileReader()\n      reader.onload = () => r(reader.result)\n      reader.readAsDataURL(new Blob([buffer]))\n    });\n    // remove the `data:...;base64,` part from the start\n    return base64url;\n}\n\nasync function base64ToUint8Array(base64) {\n    const response = await fetch(base64);\n    const buffer = await response.arrayBuffer();\n    return new Uint8Array(buffer);\n}\nconst cacheName = "ftarcache";\nasync function storeInCache( url, responseData) {\n    const cache = await caches.open(cacheName); // Open or create a named cache\n    const response = new Response(responseData, {\n      headers: { \'Content-Type\': \'application/octet-stream\' }\n    });\n    await cache.put(url, response); // Store the data in the cache\n    // console.log(`Data cached for ${url}`);\n}\n\nasync function getUint8ArrayFromCache(key) {\n    const cache = await caches.open(cacheName);\n    const response = await cache.match(key);\n    \n    if (!response) {\n    //   console.log(`No data found for key: ${key}`);\n      return null;\n    }\n    \n    const arrayBuffer = await response.arrayBuffer(); // Read as ArrayBuffer\n    const uint8Array = new Uint8Array(arrayBuffer); // Convert to Uint8Array\n    // console.log(`Retrieved Uint8Array from key: ${key}`);\n    return uint8Array;\n  }\n\n\n  async function fetchBlobFromObjectURL(objectURL) {\n    const response = await fetch(objectURL); // Fetch the Blob data behind the ObjectURL\n    const blob = await response.blob(); // Get the Blob\n    return blob;\n  }\n\n  async function cacheObjectURL( key, objectURL) {\n    const blob = await fetchBlobFromObjectURL(objectURL); // Get the Blob from the ObjectURL\n    const cache = await caches.open(cacheName); // Open the cache\n    const response = new Response(blob, { \n      headers: { \'Content-Type\': blob.type || \'application/octet-stream\' } \n    });\n    await cache.put(key, response); // Cache the Blob\n    // console.log(`Cached ObjectURL under key: ${key}`);\n  }\n\n\n  async function retrieveObjectURLFromCache( key) {\n    const cache = await caches.open(cacheName);\n    const response = await cache.match(key); // Retrieve the cached Response\n  \n    if (!response) {\n    //   console.log(`No data found for key: ${key}`);\n      return null;\n    }\n  \n    const blob = await response.blob(); // Convert the Response to a Blob\n    const objectURL = URL.createObjectURL(blob); // Recreate the ObjectURL\n    // console.log(`Recreated ObjectURL from cache for key: ${key}`);\n    return objectURL;\n  }\n\n  async function listCacheKeys() {\n    const cache = await caches.open(cacheName); // Open the specific cache\n    const keys = await cache.keys(); // Get all keys (URLs) in the cache\n    // console.log(`Cache keys in ${cacheName}:`, keys);\n    return [keys,cache];\n  }\n\nasync function fetchArrayBuffer(url){\n  const response = await fetch(url)\n  if (!response.ok){\n    console.error(`can\'t load from ${url}`)\n    return\n  }\n  let arrayBuffer;\n  try {\n    arrayBuffer = await response.arrayBuffer();\n  } catch (error) {\n    console.error(`Error while reading arrayBuffer: ${error.message}`);\n    return;\n  }\n  return arrayBuffer\n}\nasync function mediaStreamFromArrayBufer(arrayBuffer,audioContext,callback){\n\n\n  let audioBuffer;\n  try {\n    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n  } catch (error) {\n    console.error(`Error while decoding audio data: ${error.message}`);\n    return;\n  }\n  const bufferSource = audioContext.createBufferSource();\n  bufferSource.buffer = audioBuffer;\n\n  const destination = audioContext.createMediaStreamDestination();\n  let isStoped = false\n\n  bufferSource.connect(destination);\n  const mediaStream = destination.stream;\n  bufferSource.onended = () => {\n      // console.log(\'Playback has finished.\');\n      if (!isStoped){\n        const track = mediaStream.getAudioTracks()[0]\n        if (track){\n          track.stop()\n          track.dispatchEvent(new Event("ended"));\n        }\n        // callback()\n      }\n  };\n\n \n\n  bufferSource.start();\n\n  mediaStream.stopBufferSource = ()=>{\n      isStoped = true\n      bufferSource.stop()\n  }\n  return mediaStream;\n}\n\nasync function mediaStreamFromUrl(url,audioContext,callback){\n\n    const arrayBuffer = await fetchArrayBuffer(url)\n    if (!arrayBuffer) return \n    return mediaStreamFromArrayBufer(arrayBuffer,audioContext,callback)\n}\n\nconst imageMimeTypes = [\n  "image/jpeg","image/png","image/bmp","image/webp","image/avif","image/x-portable-bitmap",\n  "image/x-portable-anymap","image/x-portable-pixmap","image/tiff"\n]\n\nfunction checkFileType(fileType, typelist){\n  for (const mimeType of typelist){\n      \n      if (fileType == mimeType) {\n          return true\n      }\n  }\n  return false\n}\n\n//# sourceURL=webpack://VCAM/../util/util.js?')},"./src/v-cam-lib.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_rtc_connection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/rtc-connection.js */ "../util/rtc-connection.js");\n/* harmony import */ var _util_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/util.js */ "../util/util.js");\n\n\n\n// let vCamIframe\nfunction getVCamElement(iframeUrl,token){\n    return new VCam(iframeUrl,token)\n}\n\nclass VCam {\n    #onoutputstream\n    #reloadTokenFunc = async () => {}\n    #errorCalback = ()=> {}\n    setupTokenFetch(url,opts){\n        let firstTry = true\n        this.#reloadTokenFunc = async () => {\n            if (firstTry &&  this.opts?.token){\n                firstTry = false\n                return this.opts.token\n            }\n            try{\n                const response = await fetch(url,opts)\n                if (!response.ok){\n                    this.#errorCalback({response})\n                    return \n                }\n                const tokenJson = await response.json()\n                if (!tokenJson.token){\n                    throw new ReferenceError("token field is undefined")\n                }\n                return tokenJson.token\n            }catch (exception){\n                this.#errorCalback({exception})\n                return\n            }\n        }\n    }\n    \n    set ontokenerror(val){\n        this.#errorCalback = val\n    }\n    set background(src){\n        (async ()=>{\n            const resp = await fetch(src);\n            if (!resp.ok){\n                console.error("can not fetch ",src)\n                return\n            }\n            const imageBuffer = await resp.arrayBuffer()\n            console.log("bckg lreceaved",imageBuffer)\n            await this.iframeLoadedPromise\n            console.log("bckg loaded and sent")\n            this.iframe.contentWindow.postMessage({flexatar:{type:"background",imageBuffer}}, "*")\n   \n        })()\n       \n    }\n    constructor(iframeUrl,opts){\n        this.id = crypto.randomUUID()\n        // if (!opts.size){\n        //     opts.size = {width:"60px",height:"320px"}\n        // }\n        this.opts = opts\n        if (opts?.token){\n            this.#reloadTokenFunc = ()=>{\n                return opts.token\n            }\n        }\n        this.iframe = document.createElement("iframe")\n        this.isVideoOutputReady = false\n        let videoOutResolver \n        \n        this.videoOutReadyPromise = new Promise(resolve =>{\n            videoOutResolver = resolve\n        })\n        this.videoOutResolver = videoOutResolver\n        \n        window.addEventListener(\'message\', async event => {\n            let data = event.data;\n            console.log(data)\n            if (!data.flexatar) return\n            data = data.flexatar\n            data = data[this.id]\n            if (!data) return\n               \n            if (data.type === \'answer\') {\n                this.mediaConnection.recvAnswer(data)\n        \n            } else if (data.type === \'ice-candidate\') {\n        \n                this.mediaConnection.addIceCandidate(data)\n            } if (data.type === \'offer\') {\n                this.mediaConnection.recvOffer(data)\n        \n            } else if (data.type === \'ftarvideoready\') {\n                \n                // this.iframe.contentWindow.postMessage({flexatar:await this.mediaConnection.offerMessage()}, \'*\');\n            }else if (data.type === \'reload_token\') {\n                this.iframe\n                const token = await this.#reloadTokenFunc()\n                this.iframe.contentWindow.postMessage({flexatar:{type:"reload_token",token}}, "*")\n\n                \n                // this.iframe.contentWindow.postMessage({flexatar:await this.mediaConnection.offerMessage()}, \'*\');\n            }\n            \n        });\n        \n        this.iframeLoadedPromise = new Promise(resolve=>{\n            this.iframe.onload = async ()=>{\n                this.iframe.contentWindow.postMessage({flexatar:{token:true}}, "*");\n                resolve()\n            }\n        })\n        this.iframe.src = `${iframeUrl}?id=${this.id}`\n        this.iframe.style.width = "100%"\n        this.iframe.style.height = "100%"\n        this.iframe.style.border = "none"\n        this.iframe.style.position = "absolute"\n        this.iframe.style.top = "0"\n        this.iframe.style.left = "0"\n        // this.iframe.style.height=this.opts.size.height\n        // this.iframe.style.width=this.opts.size.width\n        \n    }\n    #playingAudioStream\n    set src(src){\n        if (!src){\n            this.audiotrack=null\n        }\n        if (src instanceof MediaStream) {\n            this.audiostream = src;\n        } else if (typeof src === \'string\') {\n            this.url=src\n        } else if (src instanceof ArrayBuffer ) {\n            this.arraybuffer=src\n        } else if (src instanceof MediaStreamTrack ) {\n            if (src.kind == "audio")\n                this.audiotrack=src\n        }\n    }\n    set url(url){\n        if (!url){\n            this.audiotrack=null\n        }\n        (async () => {\n            const arrayBuffer = await (0,_util_util_js__WEBPACK_IMPORTED_MODULE_1__.fetchArrayBuffer)(url)\n            if (arrayBuffer)\n                this.arraybuffer = arrayBuffer\n        })()\n    }\n    set audiotrack(audiotrack){\n        (async () => {\n            // console.log("mediaStream provided")\n            await this.videoOutReadyPromise\n            if (audiotrack){\n                audiotrack.onended = ()=>{\n                    console.log("track ended")\n                    this.mediaConnection.addAudioTrack(null)\n                    this.mediaConnection.isNegotiating = false\n                }\n            }\n           \n            // console.log("setting audiotrack",mediaStream)\n            this.mediaConnection.addAudioTrack(audiotrack)\n            this.mediaConnection.isNegotiating = false\n           \n        })()\n        \n    }\n    set arraybuffer(arraybuffer){\n        if (!arraybuffer){\n            this.audiotrack=null\n        }\n        (async () => {\n            if (this.#playingAudioStream){\n                this.#playingAudioStream.stopBufferSource()\n            }\n            this.#playingAudioStream = await (0,_util_util_js__WEBPACK_IMPORTED_MODULE_1__.mediaStreamFromArrayBufer)(arraybuffer,VCam.#getAudioContext(),()=>{\n                // console.log("url play stoped" )\n                this.#playingAudioStream = null\n                // this.audiostream = null\n            })\n            this.audiostream = this.#playingAudioStream\n        })()\n    }\n    static #audioContext\n    static #getAudioContext(){\n        if (!VCam.#audioContext){\n            VCam.#audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        }\n        return VCam.#audioContext\n    }\n    set audiostream(mediaStream){\n        if (!mediaStream){\n            this.audiotrack = null\n            return\n        }\n        const audioTrack = mediaStream.getAudioTracks()[0]\n        console.log(audioTrack)\n        this.audiotrack = audioTrack\n        // (async () => {\n        //     // console.log("mediaStream provided")\n        //     await this.videoOutReadyPromise\n        //     // console.log("setting audiotrack",mediaStream)\n        //     this.mediaConnection.addAudioTrack(mediaStream)\n        //     this.mediaConnection.isNegotiating = false\n        // })()\n    }\n\n    set onoutputstream(callback){\n        this.#onoutputstream = callback\n    }\n    mediastream = new MediaStream();\n    \n    mount(element){\n        element.style.position = "relative"; \n        element.appendChild(this.iframe)\n        if (this.mediaConnection) return\n\n        this.mediaConnection = new _util_rtc_connection_js__WEBPACK_IMPORTED_MODULE_0__.MediaConnectionProvider(this.iframe.contentWindow,"host")\n        this.mediaConnection.ondelayedaudio  = (audioTrack)=>{\n            if (this.oldTarck){\n                this.mediastream.removeTrack(this.oldTarck);\n                \n            }\n            this.oldTarck = audioTrack\n            this.mediastream.addTrack(audioTrack);\n            console.log("plaing tracks",this.mediastream.getTracks())\n        }\n        this.mediaConnection.onflexatarready = ftarTrack =>{\n            this.videoOutResolver()\n            this.mediastream.addTrack(ftarTrack);\n            if (this.#onoutputstream) this.#onoutputstream( this.mediastream)\n            \n        }\n    }\n    unmount(element){\n        element.remove()\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    getVCamElement\n  });\n\n//# sourceURL=webpack://VCAM/./src/v-cam-lib.js?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/v-cam-lib.js");return __webpack_exports__})()));